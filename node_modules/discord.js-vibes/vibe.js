/*
MIT License

Copyright (c) 2019 Oliver James Kennewell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

//Constants
const Discord = require("discord.js");
const search = require("youtube-search");
const ytdl = require("ytdl-core");
const ytpl = require("ytpl");
const PACKAGE = require("./package.json");

//Variables
let queue = {};

/*

 * @param {Client} bot - The discord.js client.

 * @param {object} options - Options to configure the client bot.

*/

//Start the module
exports.start = (bot, options) => {

    //Music class
    class Music {

        //Options
        constructor(bot, options) {

            this.youtubeAPIKey = (options && options.youtubeAPIKey);

            this.botPrefix = (options && options.botPrefix) || "!";

            this.embedColor = (options && options.embedColor) || "#287aff";

            this.maxVolume = parseInt((options && options.maxVolume) || 200);

            this.botLogging = (options && typeof options.botLogging !== 'undefined' ? options && options.botLogging : true);

            this.largeImage = (options && typeof options.largeImage !== 'undefined' ? options && options.largeImage : false)

            this.playAlias = (options && options.playAlias) || null;

            this.pauseAlias = (options && options.pauseAlias) || null;

            this.resumeAlias = (options && options.resumeAlias) || null;

            this.leaveAlias = (options && options.leaveAlias) || null;

            this.skipAlias = (options && options.skipAlias) || null;

            this.queueAlias = (options && options.queueAlias) || null;

            this.repeatAlias = (options && options.repeatAlias) || null;

            this.volumeAlias = (options && options.volumeAlias) || null;

            this.searchAlias = (options && options.searchAlias) || null;

        }

    }

    //Export music class
    let music = new Music(bot, options);
    exports.bot = music;

    //Ready event
    bot.on("ready", () => {

        //If bot logging is true 
        if (music.botLogging === true) {

            //Log infomation
            console.log(`–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.`);


        }

    });

    //Message event
    bot.on("message", async message => {

        //Variables
        let args = message.content.slice(music.botPrefix.length).trim().split(/ +/g);
        let cmd = args.shift().toLowerCase();

        //If there isn't a queue already
        if (!queue[message.guild.id]) queue[message.guild.id] = {
            queue: [],
            songNames: [],
            songRequesters: [],
            loop: false,
            volume: 100
        };

        //If the message doesn't start with the prefix
        if (!message.content.startsWith(music.botPrefix)) return;

        //If the author is a bot
        if (message.author.bot) return;

        //Commands
        if ((cmd === "play") || (cmd === music.playAlias)) {
            playCMD(message, args)
        }

        if ((cmd === "pause") || (cmd === music.pauseAlias)) {
            pauseCMD(message, args)
        }

        if ((cmd === "resume") || (cmd === music.resumeAlias)) {
            resumeCMD(message, args);
        }

        if ((cmd === "leave") || (cmd === music.leaveAlias)) {
            leaveCMD(message, args);
        }

        if ((cmd === "skip") || (cmd === music.skipAlias)) {
            skipCMD(message, args);
        }

        if ((cmd === "queue") || (cmd === music.queueAlias)) {
            queueCMD(message, args);
        }

        if ((cmd === "repeat") || (cmd == music.repeatAlias)) {
            repeatCMD(message, args);
        }

        if ((cmd === "volume") || (cmd === music.volumeAlias)) {
            volumeCMD(message, args);
        }

        if ((cmd === "search") || (cmd === music.searchAlias)) {
            searchCMD(message, args);
        }

    });

    //Dispatcher function
    async function dispatcher(connection, message) {

        //Get the server
        let server = queue[message.guild.id];

        //Start the queue
        server.dispatcher = connection.playStream(ytdl(server.queue[0], { filter: "audioonly" }));

        //Set the volume
        server.dispatcher.setVolume(parseInt(server.volume / 100));

        //End event
        server.dispatcher.on("end", async function() {

            //If the bot isn't in a voice channel
            if (!message.guild.me.voiceChannel) return;

            //If the repeat is disabled
            if (server.loop === false) {

                //Return the arrays
                await server.queue.shift();
                await server.songNames.shift();
                await server.songRequesters.shift();

            };

            //If theres another song
            if (server.queue[0]) {

                //Repeat the function
                dispatcher(connection, message);

                //If repeat is enabled
                if (server.loop === true) return;

                //Get the ID of the video
                let id = await ytdl.getVideoID(server.queue[0]);

                //Send the now playing
                let nowPlaying = new Discord.RichEmbed()
                    .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                    .setColor(music.embedColor)
                    .setTitle(`**–°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç: ** ${server.songNames[0]}`)
                    .setURL(server.queue[0])
                    .addField("–ó–∞–∫–∞–∑–∞–ª: ", server.songRequesters[0], true)
                    .addField("–ì—Ä–æ–º–∫–æ—Å—Ç—å: ", server.volume, true)
                if (music.largeImage === true) nowPlaying.setImage(`https://img.youtube.com/vi/${id}/maxresdefault.jpg`);
                if (music.largeImage === false) nowPlaying.setThumbnail(`https://img.youtube.com/vi/${id}/maxresdefault.jpg`);
                message.channel.send(nowPlaying);

            }

            //If there is no songs left
            if (!server.queue[0]) {

                //Leave the channel
                message.guild.me.voiceChannel.leave();

                //Send the message
                message.channel.send("üéµ | –ü–ª–µ–π–ª–∏—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω...")
                    .then(msg => msg.delete(6000));

            }

        });

    }

    async function playCMD(message, args) {

        //If the user is not in a voice channel
        if (!message.member.voiceChannel) return message.channel.send("‚õî | –í—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.").then(msg => msg.delete(6000));

        //If the songs name isn't specified
        if (!args.join(" ")) return message.channel.send("‚õî | –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø–µ—Å–Ω—é, –∫–æ—Ç–æ—Ä—É—é –í—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ—Å–ª—É—à–∞—Ç—å...").then(msg => msg.delete(6000));

        //If a URL is given
        let string;
        string = args.join(" ");

        //If string is a youtube.be link
        if (string.includes("https://youtu.be/")) string = `https://www.youtube.com/watch?v=${string.split("https://youtu.be/")[1]}`;

        //Check for '&' and split them
        if (string.includes("https://www.youtube.com/") && string.includes("&")) string = string.split("&")[1];

        //If it's a playlist link
        if (string.includes("list=")) {

            //Get the playlist ID
            let playlistID = string.toString().split("list=")[1];

            //If the playlist ID includes a '?'
            if (playlistID.includes("?")) playlistID = playlistID.split("?")[0];

            //If the playlist ID includes a '&t='
            if (playlistID.includes("&t=")) playlistID = playlistID.split("&t=")[0];

            //Get the playlist items
            ytpl(playlistID, async function(err, playlist) {

                //If there is an error
                if (err) message.channel.send("‚õî | –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ —Å –ø–æ–ª—É—á–µ–Ω–∏–µ–º –¥–∞–Ω–Ω–æ–≥–æ –ø–ª–µ–π–ª–∏—Å—Ç–∞...").then(msg => msg.delete(6000));

                //Get the server queue
                let server = queue[message.guild.id];

                //Push the information to the arrays
                playlist.items.forEach((song) => {

                    //Push to the arrays
                    server.queue.push(song.url_simple);
                    server.songNames.push(song.title);
                    server.songRequesters.push(message.author.tag);

                });

                //If the bot isn't playing in a channel
                if (!message.guild.voiceConnection) await message.member.voiceChannel.join().then(function(connection) {

                    //Run the dispatcher function
                    dispatcher(connection, message);

                });

                //Send the added to queue
                let addedToQueue = new Discord.RichEmbed()
                    .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                    .setColor(music.embedColor)
                    .setTitle(`**–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: ** ${playlist.title}`)
                    .setURL(playlist.url)
                    .addField("–ó–∞–∫–∞–∑–∞–ª: ", message.author.tag, true)
                if (music.largeImage === true) addedToQueue.setImage(playlist.items[0].thumbnail);
                if (music.largeImage === false) addedToQueue.setThumbnail(playlist.items[0].thumbnail);
                message.channel.send(addedToQueue);



            });

        }

        //If it isn't a playlist

        //Get the search options
        var opts = {
            maxResults: 1,
            key: music.youtubeAPIKey
        };

        search(string, opts, async function(err, results) {

            //If there's an error
            if (err) return message.channel.send("‚õî | –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ —Å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º –¥–∞–Ω–Ω–æ–π –ø–µ—Å–Ω–∏...").then(msg => msg.delete(6000));

            //Server
            let server = queue[message.guild.id];

            //Push to the arrays
            server.queue.push(results[0].link);
            server.songNames.push(results[0].title);
            server.songRequesters.push(message.author.tag);

            //Get the video ID
            let id = ytdl.getVideoID(results[0].link);

            //Send the added to queue
            let addedToQueue = new Discord.RichEmbed()
                .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                .setColor(music.embedColor)
                .setTitle(`**–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: ** ${results[0].title}`)
                .setURL(results[0].link)
                .addField("–ó–∞–∫–∞–∑–∞–ª: ", message.author.tag, true)
            if (music.largeImage === true) addedToQueue.setImage(`https://img.youtube.com/vi/${id}/maxresdefault.jpg`);
            if (music.largeImage === false) addedToQueue.setThumbnail(`https://img.youtube.com/vi/${id}/maxresdefault.jpg`);
            message.channel.send(addedToQueue);

            //If the bot isn't playing in a channel
            if (!message.guild.voiceConnection) await message.member.voiceChannel.join().then(function(connection) {

                //Run the dispatcher function
                dispatcher(connection, message);

            });

        });

    }

    async function pauseCMD(message, args) {

        //Get the queue
        let server = queue[message.guild.id];

        //Check if there is anything playing
        if (!server.queue[0]) return message.channel.send("‚õî | –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—á–µ–≥–æ —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –ø–∞—É–∑—É.").then(msg => msg.delete(6000));

        //Pause the song
        server.dispatcher.pause();

        //Send the confirmation
        message.channel.send("‚è∏ | –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.").then(msg => msg.delete(6000));

    }

    async function resumeCMD(message, args) {

        //Get the queue
        let server = queue[message.guild.id];

        //If there is nothing in the queue 
        if (server.dispatcher.paused === false) return message.channel.send("‚õî | –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–∞—á–∏–Ω–∞—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—å –Ω–µ—á–µ–≥–æ.").then(msg => msg.delete(6000));

        //Resume the song
        server.dispatcher.resume();

        //Send the confirmation
        message.channel.send("‚ñ∂ | –ù–∞—á–∞—Ç–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ.").then(msg => msg.delete(6000));

    }

    async function leaveCMD(message, args) {

        //Check if the bot is in a voice channel
        if (!message.guild.me.voiceChannel) return message.channel.send("‚õî | –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤—ã–π—Ç–∏ –Ω–µ –æ—Ç–∫—É–¥–∞.").then(msg => msg.delete(6000));

        //Check if the member is in the bots voice channel
        if (message.member.voiceChannel !== message.guild.me.voiceChannel) return message.channel.send("‚ùå | –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–π–¥–∏—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–∞–Ω–∞–ª —Å–æ –º–Ω–æ–π.").then(msg => msg.delete(6000));

        //Get the server
        let server = queue[message.guild.id];

        //Clear the queue
        server.queue = []

        //Leave the voice channel
        message.guild.me.voiceChannel.leave();

        message.channel.send("üí® | –í—ã—à–µ–ª —Å –∫–∞–Ω–∞–ª–∞.").then(msg => msg.delete(6000));
    }

    async function skipCMD(message, args) {

        //Get the server
        let server = queue[message.guild.id];

        //Check if there is a queue
        if (!server.queue[0]) return message.channel.send("‚õî | –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è.").then(msg => msg.delete(6000));

        //Turn loop off
        server.loop = false

        //Pause
        server.dispatcher.end();

        message.channel.send("‚è© | –ü—Ä–æ–ø—É—â–µ–Ω–∞ –ø–µ—Å–Ω—è. –ü–µ—Ä–µ—Ö–æ–¥...").then(msg => msg.delete(6000));
    }


    async function queueCMD(message, args) {

        //Get the server
        let server = queue[message.guild.id];

        //Check if there is a queue
        if (server.queue[0] === null) return message.channel.send("‚õî | –í —Å–ø–∏—Å–∫–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.").then(msg => msg.delete(6000));

        //JavaScript arrays
        let names = [];

        //Push the song names
        server.songNames.forEach((song) => {

            //Push to Names array
            names.push(song);

        });

        //If the queue is bigger than 10
        if (names.length > 10) {

            //Send the embed
            let embed = new Discord.RichEmbed()
                .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                .setColor(music.embedColor)
                .setTitle("–û—á–µ—Ä–µ–¥—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: ", message.guild.name)
                .setThumbnail(message.guild.iconURL)
                .setDescription(`**–≠—Ç–∞ –æ—á–µ—Ä–µ–¥—å —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –ø–µ—Ä–≤—ã—Ö 10 –ø–µ—Å–µ–Ω —Å–ø–∏—Å–∫–∞: **\n\n1. ${names[0]}\n2. ${names[1]}\n3. ${names[2]}\n4. ${names[3]}\n5. ${names[4]}\n6. ${names[5]}\n7. ${names[6]}\n8. ${names[7]}\n9. ${names[8]}\n10. ${names[9]}`)
            message.channel.send(embed);

            //Stop other code from running
            return;

        }

        //If the queue is 10 or under
        let embed = new Discord.RichEmbed()
            .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
            .setColor(music.embedColor)
            .setTitle("–û—á–µ—Ä–µ–¥—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: ", message.guild.name)
            .setThumbnail(message.guild.iconURL)
            .setDescription(`${names.slice(0,15).join('\n')}`)
        message.channel.send(embed);

    }

    async function repeatCMD(message, args) {

        //Get the servers queue
        let server = queue[message.guild.id];

        //Check if there is a queue
        if (server.queue[0] === null) return message.channel.send("‚õî | –í —Å–ø–∏—Å–∫–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.").then(msg => msg.delete(6000));

        if (server.loop === false) {

            //Enable the loop
            server.loop = true

            message.channel.send("üîÇ | –ü–æ–≤—Ç–æ—Ä –æ—á–µ—Ä–µ–¥–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è **–≤–∫–ª—é—á–µ–Ω**.").then(msg => msg.delete(6000));

        } else if (server.loop === true) {

            //Disable
            server.loop = false

            message.channel.send("üîÅ | –ü–æ–≤—Ç–æ—Ä –æ—á–µ—Ä–µ–¥–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è **–≤—ã–∫–ª—é—á–µ–Ω**.").then(msg => msg.delete(6000));

        }
    }

    async function volumeCMD(message, args) {

        //Get the servers queue
        let server = queue[message.guild.id];

        if (!server.queue[0]) return message.channel.send("‚õî | –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è.").then(msg => msg.delete(6000));

        //Check if a volume is specified
        if (!args[0]) return message.channel.send(`‚õî | –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ-–≥—Ä–æ–º–∫–æ—Å—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 1 –¥–æ ${music.maxVolume} –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ **${music.botPrefix}volume current** –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.`).then(msg => msg.delete(6000));

        let opt = args[0].toLowerCase();
        if (opt === "current") {

            let embed = new Discord.RichEmbed()
                .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                .setColor(music.embedColor)
                .setTitle("–ì—Ä–æ–º–∫–æ—Å—Ç—å –º—É–∑—ã–∫–∏")
                .setThumbnail(message.guild.iconURL)
                .setDescription("**–ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç: ** " + server.volume)
            message.channel.send(embed);

            return;
        } else {

            //Check if the Volume mentions is a number
            if (isNaN(args[0])) return message.channel.send("‚õî | –ì—Ä–æ–º–∫–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∞ —á–∏—Å–ª–æ–º.").then(msg => msg.delete(6000));

            //Check some things
            if (args[0] > music.maxVolume) return message.channel.send("‚õî | –í–∞–º–∏ –≤–≤–µ–¥–µ–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –±–æ–ª—å—à–µ, —á–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π.").then(msg => msg.delete(6000));
            if (args[0] < 1) return message.channel.send("‚õî | –í–∞–º–∏ –≤–≤–µ–¥–µ–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –º–µ–Ω—å—à–µ, —á–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π.").then(msg => msg.delete(6000));

            //Get the dispatcher
            let dispatcher = message.guild.me.voiceChannel.connection.player.dispatcher;

            //Set the volume
            dispatcher.setVolume(args[0] / 100);

            //Set volume in the server array
            server.volume = args[0];

            //Send the confirmation
            message.channel.send("‚è´ | –£—Ä–æ–≤–µ–Ω—å –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ " + server.volume + ".").then(msg => msg.delete(6000));
        }
    }

    async function searchCMD(message, args) {

        //Get the servers queue
        let server = queue[message.guild.id];

        //Check if a song is mentioned
        if (!args.join(" ")) return message.channel.send("‚õî | –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –¥–ª—è –µ–µ –ø–æ–∏—Å–∫–∞...").then(msg => msg.delete(6000));

        //If the author isn't in a voice channel
        if (!message.member.voiceChannel) return message.channel.send("‚õî | –í—ã –¥–æ–ª–∂–Ω—ã –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã.").then(msg => msg.delete(6000));

        //Get the search string7
        let searchString = args.join(" ");

        //Get the search options
        var opts = {
            maxResults: 5,
            key: music.youtubeAPIKey
        };

        //Search for the YouTube video
        search(searchString, opts, async function(err, results) {

            //If there is an error
            if (err) return message.channel.send("‚õî | –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –ø–µ—Å–Ω–∏...").then(msg => msg.delete(6000));

            //Start number
            let start = 0;

            //Send the embed 
            let embed = new Discord.RichEmbed()
                .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                .setColor(music.embedColor)
                .setTitle("–ù–∞–π–¥–µ–Ω–æ: " + searchString)
                .setDescription("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ ‚ùå, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–ª–∏ –Ω–∞ ‚úÖ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å.")
                .addField("–ù–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏: ", results[start].title)
                .setImage(results[start].thumbnails.high.url)
            message.channel.send(embed).then(async embedMessage => {

                //React with the emojis
                await embedMessage.react("‚ùå");
                await embedMessage.react("‚úÖ");

                //Emoji reaction function
                async function reactEmojis(msg) {
                    await msg.react("‚ùå");
                    await msg.react("‚úÖ");
                }

                //Filters
                let checkFilter = (reaction, user) => reaction.emoji.name === "‚úÖ" && user.id === message.author.id;
                let crossFilter = (reaction, user) => reaction.emoji.name === "‚ùå" && user.id === message.author.id;

                let check = embedMessage.createReactionCollector(checkFilter, { time: 60000 });
                let cross = embedMessage.createReactionCollector(crossFilter, { time: 60000 });

                //Events 
                check.on("collect", async m => {

                    //Delete the message
                    embedMessage.delete();

                    //Push the info
                    server.queue.push(results[start].link);
                    server.songRequesters.push(message.author.tag);
                    server.songNames.push(results[start].title);

                    //Send the 'Added to queue' message
                    let embed = new Discord.RichEmbed()
                        .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                        .setColor(music.embedColor)
                        .setTitle(results[start].title)
                        .setURL(results[start].link)
                        .setImage(`https://img.youtube.com/vi/${results[start].id}/maxresdefault.jpg`)
                        .addField("–ó–∞–∫–∞–∑–∞–ª: ", message.author.tag)
                    message.channel.send(embed);

                    //Play the queue if the bot is not already
                    if (!message.guild.voiceConnection) await message.member.voiceChannel.join().then(function(connection) {
                        dispatcher(connection, message);
                    });

                    //Reset the start number
                    start = 0;

                });

                cross.on("collect", async m => {

                    //If the 5th result has already been shown delete the message
                    if (start === 4) return embedMessage.delete() && message.channel.send("‚õî | –í—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—ã–ª–∏ –≤—ã–≤–µ–¥–µ–Ω—ã.").then(msg => msg.delete(6000));

                    //Remove all emojis
                    await embedMessage.clearReactions();

                    //React to the message again
                    reactEmojis(embedMessage);

                    //Change the number
                    start = parseInt(start + 1);

                    //Edit the embed
                    let embed = new Discord.RichEmbed()
                        .setTitle("–°–∏—Å—Ç–µ–º–∞ –º—É–∑—ã–∫–∏")
                        .setColor(music.embedColor)
                        .setTitle("–ù–∞–π–¥–µ–Ω–æ: " + searchString)
                        .setDescription("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ ‚ùå, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–ª–∏ –Ω–∞ ‚úÖ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å.")
                        .addField("–ù–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏: ", results[start].title)
                        .setImage(results[start].thumbnails.high.url)
                    embedMessage.edit(embed);


                });

            });
        });

    }

};